callId

```
     * //----------------------------|--------------------------------|
     * // workerID (int) (workerId >> 32) | 调用ID (int) ++nextcallId  |
```

首先，`callId` 的值是通过将 `srv.id` 左移 32 位（即将 `this.id` 作为高 32 位，低 32 位为 0）再加上 `nextCallId++` 得到的。因此，`callId` 包含了两个部分：高 32 位是发送请求时的 `srv.id`，低 32 位是请求的序号。

然后，在处理响应时，需要从 `callId` 中提取出发送请求时的 `srv.id`，以便找到相应的请求处理程序。这里使用位运算来提取 `srv.id`，具体地，通过将 `callId` 右移 32 位得到高 32 位，再将其强制转换为 `int` 类型得到发送请求时的 `srv.id`。

综上，这样处理可以将 `callId` 分成两部分，在处理响应时能够正确地**提取**出发送请求时的 `srv.id`，从而找到相应的请求处理程序

Q:直接用序号可以吗

> 在分布式系统中，为了避免不同节点之间生成的请求序号重复，通常会采用一些复杂的方法来生成唯一的请求ID。这里使用了 `(long) srv.id << 32 | nextCallId++` 这种方式生成请求ID，可以确保请求ID的唯一性。
>
> 如果仅仅使用序号来进行请求ID的生成，那么在分布式系统中可能会出现不同节点之间生成的请求序号重复的情况，导致请求ID冲突，无法正确处理响应。使用高位和低位的方式，将请求ID分成了两部分，高位表示节点ID，低位表示请求序号，从而保证了不同节点之间生成的请求ID不会重复。
>
> 因此，采用高位和低位的方式来生成请求ID，可以更好地保证请求ID的唯一性和可靠性，从而确保分布式系统的正常运行。